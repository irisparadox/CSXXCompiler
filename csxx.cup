package syntax;

import java_cup.runtime.*;
import lex.AnalizadorLexicoTiny;
import lex.UnidadLexica;
import lex.TokenValue;
import errors.GestionErroresTiny;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};

terminal OPERATOR_ADD;
terminal OPERATOR_SUB;
terminal OPERATOR_MULT;
terminal OPERATOR_DIV;
terminal OPERATOR_AND;
terminal OPERATOR_OR;
terminal OPERATOR_XOR;
terminal OPERATOR_NOT;
terminal OPERATOR_MOD;

terminal OPERATOR_BAND;
terminal OPERATOR_BOR;
terminal OPERATOR_BNOT;
terminal OPERATOR_EQUAL;
terminal OPERATOR_NEQ;
terminal OPERATOR_GT;
terminal OPERATOR_LT;
terminal OPERATOR_GEQ;
terminal OPERATOR_LEQ;

terminal OPERATOR_PP;
terminal OPERATOR_MM;

terminal EQUALS;
terminal COMA;
terminal SEMI_COLON;
terminal DOT;
terminal TYPE_IDENT;

terminal PARENTH_OPEN;
terminal PARENTH_CLOSE;
terminal BRACKET_OPEN;
terminal BRACKET_CLOSE;
terminal CURLY_OPEN;
terminal CURLY_CLOSE;

terminal VOID;
terminal IDENTIFICATOR;
terminal NUMBER_NAT;
terminal NUMBER_INT;
terminal NUMBER_FLOAT;
terminal NUMBER_BIN;
terminal NUMBER_HEX;
terminal RVAL_CHAR;
terminal RVAL_CHAR_ARR;

terminal UINT8;
terminal UINT16;
terminal UINT32;
terminal UINT64;

terminal INT8;
terminal INT16;
terminal INT32;
terminal INT64;

terminal FLOAT32;
terminal FLOAT64;

terminal BOOL;
terminal TRUE;
terminal FALSE;

terminal CHAR;
terminal UCHAR;

terminal STRUCT;

terminal IF;
terminal ELSEIF;
terminal ELSE;

terminal WHILE;
terminal FOR;
terminal LOOP;
terminal CURSOR;
terminal FUNCTION;

non terminal S, INSTRUCTIONS, INSTRUCTION;
non terminal DECLARATIONS, DECLARATION, ASSIGNATION, ARRASSIGN;
non terminal TYPEDEC, STRUCTDEC, ARRDEC;
non terminal E EXP0, EXP1, EXP2, EXP3, EXP4, EXP5, EXP6, EXP7;
non terminal Num VALUE;
non terminal TYPES, ARRCONTENTS, MORE_ARRCONTENTS, ARRCONTENT;

S ::= INSTRUCTIONS ;

INSTRUCTIONS ::= INSTRUCTIONS INSTRUCTION | INSTRUCTION ;
INSTRUCTION ::= DECLARATION | ASSIGNATION ;

DECLARATIONS ::= DECLARATIONS DECLARATION | DECLARATION ;
DECLARATION ::= TYPEDEC | STRUCTDEC | ARRDEC ;
ASSIGNATION ::= IDENTIFICATOR EQUALS EXP0 SEMI_COLON ;

TYPEDEC   ::= TYPES IDENTIFICATOR SEMI_COLON | TYPES IDENTIFICATOR EQUALS EXP0 SEMI_COLON ;
STRUCTDEC ::= STRUCT IDENTIFICATOR SEMI_COLON | STRUCT IDENTIFICATOR BRACKET_OPEN BRACKET_CLOSE SEMI_COLON | STRUCT IDENTIFICATOR BRACKET_OPEN DECLARATIONS BRACKET_CLOSE SEMI_COLON ;
ARRDEC    ::= TYPES BRACKET_OPEN NUMBER_NAT BRACKET_CLOSE IDENTIFICATOR SEMI_COLON | TYPES BRACKET_OPEN NUMBER_NAT BRACKET_CLOSE IDENTIFICATOR EQUALS ARRASSIGN SEMI_COLON ;

ARRASSIGN ::= CURLY_OPEN ARRCONTENTS CURLY_CLOSE | RVAL_CHAR_ARR ;

ARRCONTENTS      ::= ARRCONTENT MORE_ARRCONTENTS | /* EPSILON */ ;
MORE_ARRCONTENTS ::= COMA ARRCONTENT MORE_ARRCONTENTS | /* EPSILON */ ;
ARRCONTENT       ::= VALUE | IDENTIFICATOR ;


EXP0 ::= EXP1: Val_Exp1 OPERATOR_BAND EXP0: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.BAND); :};
EXP0 ::= EXP1: Val_Exp1 OPERATOR_BOR EXP0: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.BOR); :};
EXP0 ::= EXP1: Val_Exp1 OPERATOR_EQUAL EXP0: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.EQUAL); :};
EXP0 ::= EXP1: Val_Exp1 OPERATOR_NEQ EXP0: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.NEQ); :};
EXP0 ::= EXP1 ;


EXP1 ::= OPERATOR_BNOT EXP2: Val_Exp
         {: RESULT = new EUni(Val_Exp, UniOps.BNOT); :};
EXP1 ::= EXP2 ;


EXP2 ::= EXP3: Val_Exp1 OPERATOR_GT EXP2: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.GT); :};
EXP2 ::= EXP3: Val_Exp1 OPERATOR_LT EXP2: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.LT); :};
EXP2 ::= EXP3: Val_Exp1 OPERATOR_GEQ EXP2: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.GEQ); :};
EXP2 ::= EXP3: Val_Exp1 OPERATOR_LEQ EXP2: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.LEQ); :};
EXP2 ::= EXP3 ;


EXP3 ::= EXP4: Val_Exp1 OPERATOR_ADD EXP3: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.PLUS); :};
EXP3 ::= EXP4: Val_Exp1 OPERATOR_SUB EXP3: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.MINUS); :};
EXP3 ::= EXP4 ;


EXP4 ::= EXP5: Val_Exp1 OPERATOR_MULT EXP4: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.MULT); :};
EXP4 ::= EXP5: Val_Exp1 OPERATOR_DIV EXP4: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.DIV); :};
EXP4 ::= EXP5: Val_Exp1 OPERATOR_MOD EXP4: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.MOD); :};
EXP4 ::= EXP5 ;


EXP5 ::= EXP6: Val_Exp1 OPERATOR_AND EXP5: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.AND); :};
EXP5 ::= EXP6: Val_Exp1 OPERATOR_OR EXP5: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.OR); :};
EXP5 ::= EXP6: Val_Exp1 OPERATOR_XOR EXP5: Val_Exp0
         {: RESULT = new EBin(Val_Exp1, Val_Exp0, BinOps.XOR); :}; 
EXP5 ::= OPERATOR_NOT EXP6: Val_Exp
         {: RESULT = new EUni(Val_Exp, UniOps.NOT); :};
EXP5 ::= EXP6 ;


EXP6 ::= OPERATOR_PP EXP6: Val_Exp
         {: RESULT = new EUni(Val_Exp, UniOps.PP_PRE); :};
EXP6 ::= OPERATOR_MM EXP6: Val_Exp
         {: RESULT = new EUni(Val_Exp, UniOps.MM_PRE); :};
EXP6 ::= EXP7: Val_Exp OPERATOR_PP
         {: RESULT = new EUni(Val_Exp, UniOps.PP_POST); :};
EXP6 ::= EXP7: Val_Exp OPERATOR_MM
         {: RESULT = new EUni(Val_Exp, UniOps.MM_POST); :};
EXP6 ::= EXP7 ;


EXP7 ::= VALUE | IDENTIFICATOR | PARENTH_OPEN EXP0 PARENTH_CLOSE ;

VALUE ::= NUMBER_NAT | NUMBER_INT | NUMBER_FLOAT | NUMBER_BIN | NUMBER_HEX | RVAL_CHAR | RVAL_CHAR_ARR | TRUE | FALSE ;

TYPES ::= UINT8 | UINT16 | UINT32 | UINT64 | INT8 | INT16 | INT32 | INT64 | FLOAT32 | FLOAT64 | CHAR | UCHAR | BOOL | VOID ;