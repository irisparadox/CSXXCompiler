package syntax;

import java_cup.runtime.*;
import lex.AnalizadorLexicoTiny;
import lex.UnidadLexica;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};

terminal OPERATOR_ADD;
terminal OPERATOR_SUB;
terminal OPERATOR_MULT;
terminal OPERATOR_DIV;
terminal OPERATOR_AND;
terminal OPERATOR_OR;
terminal OPERATOR_XOR;
terminal OPERATOR_NOT;
terminal OPERATOR_MOD;

terminal OPERATOR_BAND;
terminal OPERATOR_BOR;
terminal OPERATOR_BNOT;
terminal OPERATOR_EQUAL;
terminal OPERATOR_NEQ;
terminal OPERATOR_GT;
terminal OPERATOR_LT;
terminal OPERATOR_GEQ;
terminal OPERATOR_LEQ;

terminal OPERATOR_PP;
terminal OPERATOR_MM;

terminal EQUALS;
terminal COMA;
terminal SEMI_COLON;
terminal DOT;
terminal TYPE_IDENT;

terminal PARENTH_OPEN;
terminal PARENTH_CLOSE;
terminal BRACKET_OPEN;
terminal BRACKET_CLOSE;
terminal CURLY_OPEN;
terminal CURLY_CLOSE;

terminal VOID;
terminal IDENTIFICATOR;
terminal NUMBER_NAT;
terminal NUMBER_INT;
terminal NUMBER_FLOAT;
terminal NUMBER_BIN;
terminal NUMBER_HEX;
terminal RVAL_CHAR;
terminal RVAL_CHAR_ARR;

terminal UINT8;
terminal UINT16;
terminal UINT32;
terminal UINT64;

terminal INT8;
terminal INT16;
terminal INT32;
terminal INT64;

terminal FLOAT32;
terminal FLOAT64;

terminal BOOL;
terminal TRUE;
terminal FALSE;

terminal CHAR;
terminal UCHAR;

terminal STRUCT;

terminal IF;
terminal ELSEIF;
terminal ELSE;

terminal WHILE;
terminal FOR;
terminal LOOP;
terminal CURSOR;
terminal FUNCTION;

non terminal S;
non terminal DECLARATIONS, DECLARATION;
non terminal TYPE_UINT, TYPE_INT, TYPE_FLOAT;
non terminal UINTDEC, INTDEC, FLOATDEC, CHARDEC, UCHARDEC, BOOLDEC, STRUCTDEC;
non terminal ALLOWED_INT, ALLOWED_UINT, ALLOWED_FLOAT, ALLOWED_CHAR, ALLOWED_UCHAR, ALLOWED_BOOL;
non terminal EXP0;

S ::= DECLARATIONS ;

DECLARATIONS ::= DECLARATIONS DECLARATION | DECLARATION ;

DECLARATION ::= UINTDEC | INTDEC | FLOATDEC | CHARDEC | UCHARDEC | BOOLDEC | STRUCTDEC ;

UINTDEC   ::= TYPE_UINT IDENTIFICATOR SEMI_COLON | TYPE_UINT IDENTIFICATOR EQUALS NUMBER_NAT SEMI_COLON ;
INTDEC    ::= TYPE_INT IDENTIFICATOR SEMI_COLON | TYPE_INT IDENTIFICATOR EQUALS ALLOWED_INT SEMI_COLON ;
FLOATDEC  ::= TYPE_FLOAT IDENTIFICATOR SEMI_COLON | TYPE_FLOAT IDENTIFICATOR EQUALS ALLOWED_FLOAT SEMI_COLON ;
CHARDEC   ::= CHAR IDENTIFICATOR SEMI_COLON | CHAR IDENTIFICATOR EQUALS ALLOWED_CHAR SEMI_COLON ;
UCHARDEC  ::= UCHAR IDENTIFICATOR SEMI_COLON | UCHAR IDENTIFICATOR EQUALS ALLOWED_UCHAR SEMI_COLON ;
BOOLDEC   ::= BOOL IDENTIFICATOR SEMI_COLON | BOOL IDENTIFICATOR EQUALS ALLOWED_BOOL SEMI_COLON ;
STRUCTDEC ::= STRUCT IDENTIFICATOR SEMI_COLON | STRUCT IDENTIFICATOR BRACKET_OPEN DECLARATIONS BRACKET_CLOSE SEMI_COLON ;

EXP0 ::= OPERATOR_PP EXP0 | OPERATOR_MM EXP0 | 

ALLOWED_INT   ::= NUMBER_NAT | NUMBER_INT | NUMBER_BIN | NUMBER_HEX ;
ALLOWED_FLOAT ::= NUMBER_NAT | NUMBER_INT | NUMBER_FLOAT | NUMBER_BIN | NUMBER_HEX ;
ALLOWED_CHAR  ::= NUMBER_NAT | NUMBER_BIN | NUMBER_HEX | RVAL_CHAR ;
ALLOWED_UCHAR ::= NUMBER_NAT | NUMBER_INT | NUMBER_BIN | NUMBER_HEX | RVAL_CHAR ;
ALLOWED_BOOL  ::= NUMBER_NAT | NUMBER_INT | NUMBER_FLOAT | NUMBER_BIN | NUMBER_HEX | RVAL_CHAR | TRUE | FALSE ;

TYPE_UINT  ::= UINT8 | UINT16 | UINT32 | UINT64 ;
TYPE_INT   ::= INT8 | INT16 | INT32 | INT64 ;
TYPE_FLOAT ::= FLOAT32 | FLOAT64 ;